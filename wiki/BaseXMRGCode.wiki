#Page discusses the base class, xmrgFile in xmrgFile.py

= Processing an XMRG File =

This page discusses the class object used to open and process and XMRG file from the NEXRAD system.


== Required Bits and Pieces ==
===Python===
  * Python version 2.5.2
  * Non-standard packages
    * gzip(This one may be standard)
    * numpy(Might be standard as well, code usesthe zeros class)
    * [http://code.google.com/p/pysqlite/ pysqlite2]
===SQLite Stuff===
  * [http://www.gaia-gis.it/spatialite/binaries.html Spatialite] geo-spatial library for the appropriate platform(Winders or Linux)
  * [http://code.google.com/p/wqportlet/source/browse/trunk/data/databases/nexrad.db nexrad.db] database. This is a database containing the precipitation table as well as the needed geo-spatial tables.

== Getting it Running ==

This code will read various revisions of the XMRG files and store the data into the precipitation_radar table in the nexrad.db database. The database table is really just a convenient place to store the data to then perform spatial queries using the Spatialite library. The project I am working on has various watersheds I am interested in. I use the polygons that represent these watersheds to query the radar data to see what if any precipitation fell. I get the area of intersection:
{{{
SELECT * FROM(\
           SELECT (Area(Intersection(radar.geom,GeomFromText('%s')))/Area(GeomFromText('%s'))) as percent,\
                   radar.precipitation as precipitation\
           FROM precipitation_radar radar \
           WHERE radar.collection_date >= '%s' AND radar.collection_date <= '%s' AND\
                Intersects(radar.geom, GeomFromText('%s')))
}}}
and then calculate a weighted average.

The [http://code.google.com/p/wqportlet/source/browse/trunk/scripts/xmrgFile.py xmrgFile.py] script uses command line parameters to import an XMRG file. The following is an example of what your command line might look like:
{{{
python xmrgFile --DatabaseFile=".\nexrad.db" 
--BBOX="-81.1 32.8,-77.8 34" 
--SpatialiteLib="C:\Program Files\sqlite-3_5_6\libspatialite-1.dll" --XMRGFile=".\xmrg1014200916z"
--Polygon="-78.711 33.796, -78.711 33.85, -78.546 33.85, -78.546 33.839, -78.711 33.796"
}}}

Command line parameters:
    * --DatabaseFile Full path to the database used to store the imported file.
    * --SpatialiteLib Full path to the spatialite library. For windows this will be a DLL, for Linux a shared object file.
    * --XMRGFile The XMRG file to process.
    * --BBOX The bounding box to use to select the area of interest from the source XMRG file and store into the database. If not provided, the entire XMRG file is imported. The format is "Bottom Left Longitude Bottom Right Latitude, Top Right Longitude Top Right Latitude".
    * --StoreDryPrecipCells If set, when importing the XMRG file, cells that had precipitation of 0 will be stored in the database. Storing the dry cells has the potential to make the database quite large depending on the area the BBOX covers.
    * --Polygon Polygon of interest to use for querying against the radar data. The fomrat starts with the bottom left longitude and latitude, then continues around the polygon with the last longitude latitude pair once again being the bottom left.
 

== The Code ==
The [http://code.google.com/p/wqportlet/source/browse/trunk/scripts/xmrgFile.py xmrgFile.py] file contains two main objects and a couple of container objects.
  * xmrgFile is the object that handles reading an XMRG file.
  * xmrgDB is the object that handles the reads/writes from the database.
  * hrapCoord is a simple object that represents a HRAP grid coordinate.
  * LatLong is a simple latitude/longitude object.
  
  === xmrgFile Object ===
  These are the member functions in the object.
  * *__init__(loggerName=None)*
    _Purpose:_ Initalizes the class.

    _Parameters:_ None

    _Return:_ None

  * *Reset()*
  _Purpose:_ Prepares the xmrgFile object for reuse. Resets various variables and closes  the currently open file object.

  _Parameters:_ None

  _Return:_ None
  
  * *openFile(filePath)*
  _Purpose:_ Attempts to open the file given in the filePath string. If the file is compressed using gzip, this will uncompress the file as well.

  _Parameters:_
    filePath is a string with the full path to the file to open.

  _Return:_
    True if successful, otherwise False. If an error occured, it will be stored in self.lastErrorMsg

  * *cleanUp(deleteFile,deleteCompressedFile)*
 _Purpose:_ Called to delete the XMRG file that was just worked with. Can delete the uncompressed file and/or the source compressed file. 

 _Parameters:_
   deleteFile if True, will delete the unzipped binary file.
   deleteCompressedFile if True, will delete the compressed file the working file was extracted from.

  * *readFileHeader()*
  _Purpose:_ For the open file, reads the header. Call this function first before attempting to use readRow or readAllRows. If you don't the file pointer will not be at the correct position.

  _Parameters:_ None

  _Returns:_ True if successful, otherwise False.

  * *readRecordTag()*
  _Purpose:_ Reads the tag that surrounds each record in the file.

  _Parameters:_ None

  _Return:_ An integer dataArray with the tag data if read, otherwise None.

  * *readRow()*
  _Purpose:_ Reads a single row from the file.

  _Parameters:_ None'

  _Returns:_ If successful a dataArray containing the row values, otherwise None.

  * *readAllRows()*
  _Purpose:_ Reads all the rows in the file and stores them in a dataArray object. Data is stored in self.grid.

  _Parameters:_ None

  _Returns:_ True if succesful otherwise False.

  * *inBBOX(hrapPoint)*
  _Purpose:_ Tests to see if the testLatLong is in the bounding box given by minLatLong and maxLatLong.

  _Parameters:_
    testLatLong is the lat/long pair we are testing.
    minLatLong is a latLong object representing the bottom left corner.
    maxLatLong is a latLong object representing the upper right corner.

  _Returns:_
    True if the testLatLong is in the bounding box, otherwise False.

  * *hrapCoordToLatLong(hrapPoint)*
  _Purpose:_ Converts the HRAP grid point given in hrapPoint into a latitude and longitude.

  _Parameters:_
    hrapPoint is an hrapPoint object that defines the row,col point we are converting.

  _Returns:_
    A LatLong() object with the converted data.

  * *latLongToHRAP(latLong, roundToNearest=False, adjustToOrigin=False)*
  _Purpose:_ Converts a latitude and longitude into an HRAP grid point.

  _Parameters:_  
    latLong is an latLong object that defines the point we are converting.
    roundToNearest specifies if we want to round the hrap point to the nearest integer value.
    adjustToOrigin specifies if we want to adjust the hrap point to the origin of the file.

  _Returns:_
    A LatLong() object with the converted data.

  * *biLinearInterpolatePoint(x, y, z0, z1, z2, z3)*

  * _getCollectionDateFromFilename(fileName)_
  _Purpose:_ Given the filename, this will return a datetime string in the format of YYYY-MM-DDTHH:MM:SS.

  _Parameters:_
    fileName is the xmrg filename to parse the datetime from.

  _Return:_
    A string representing the date and time in the form: YYYY-MM-DDTHH:MM:SS
  
=== xmrgDB  Object ===

  * *__init__*
  _Purpose:_ Initializes the object

  _Parameters:_ None

  _Returns:_ None

  * *connect(dbFilepath, spatiaLiteLibFile='')*
  _Purpose:_ Connects to the sqlite database file passed in dbFilepath.

  _Parameters:_
    dbFilepath is the fully qualified path to the sqlite database.

  _Returns:_ True if we successfully connected to the database, otherwise False.
  If an exception occured, the stack trace is written into self.lastErrorMsg.

  * *executeQuery(sqlQuery)* 
  _Purpose:_ Executes the sql statement passed in.

  _Parameters:_
    sqlQuery is a string containing the query to execute.

  _Return:_
    If successfull, a cursor is returned, otherwise None is returned.

  * *cleanUp(olderThanDate)*
  _Purpose:_ This function will remove all data older the olderThanDate from the precipitation_radar table.

  _Parameters:_
    olderThanDate is the comparison date to use.

  _Return: _
    True if successful, otherwise False.

  * *buildPolygonString(polygonPtList)*
  _Purpose:_ Takes a list of latitudes/longitudes representing a polygon and builds a GIS POLYGON string.

  _Parameters:_
    polygonPtList is a list of x,y tuples which forms the polygon we use to determine the intersection with the radar polygons.
  _Return:_
    A GIS POLYGON string that can be used for a SQL spatial query.

  * *getRadarDataForBoundary(boundaryPolygon,strtTime,endTime)*
  _Purpose:_ For the given rain gauge(boundaryName), this function will return the radar data that is in that POLYGON.

  _Parameters:_
    boundaryPolygon is a list of x,y tuples which forms the polygon we use to determine the intersection with the radar polygons.
    strtTime is the datetime to begin the search
    endTime is the datetime to end the search.

  _Return:_
    Database cursor with the results if query is successful, otherwise None.

  * *calculateWeightedAvg(boundaryPolygon, startTime, endTime)*
  _Purpose:_ For a given station(rain gauge) this function queries the radar data, gets the grids that fall
   into the watershed of interest and calculates the weighted average.

  _Parameters:_
    boundaryPolygon is a list of longitude latitude pairs that make up the polygon. The format for the string is "longitude1 latitude1, longitude2 latitude2, ..., longitude1 latitude1".
    startTime is the starting time in YYYY-MM-DDTHH:MM:SS format.
    endTime is the starting time in YYYY-MM-DDTHH:MM:SS format.